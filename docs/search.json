[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python/R for Data Science",
    "section": "",
    "text": "Preface\nThis is the lecture notes for STAT 2304 Programming languages for Data Science Fall 2023 at ATU. If you have any comments/suggetions/concerns about the notes please contact me at xxiao@atu.edu.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Python/R for Data Science",
    "section": "References",
    "text": "References",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "contents/8/intro.html",
    "href": "contents/8/intro.html",
    "title": "1  R Fundamentals",
    "section": "",
    "text": "1.1 Hello world for R\nprint('Hello world!')\n#&gt; [1] \"Hello world!\"",
    "crumbs": [
      "Part I: R Basic",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals</span>"
    ]
  },
  {
    "objectID": "contents/8/intro.html#essential-concepts",
    "href": "contents/8/intro.html#essential-concepts",
    "title": "1  R Fundamentals",
    "section": "1.2 Essential concepts",
    "text": "1.2 Essential concepts\n\nIn R, assignments is &lt;-, not =. = actually works, but it may cause confusions. So it is always recommended to use &lt;-. The R Studio keybinding for &lt;- is alt+-.\n. is NOT a special character in R, and can be used in variable names. So is.na() simply means a function called is.na. It is not a function na in a package is as in Python.\nIn R, the block is defined by {}. Indentation is not that important.\nR has a better package management system than Python, and therefore in most cases you don’t need virtual environment for R.\n\n\n1.2.1 R Markdown / Quarto\nThe counterpart of Jupyter notebook in R is .rmd/.qmd file. Similar to a notebook, in a R Markdown / Quarto file, there is a so-called code block that can run the codes inside to produce documents with both texts and codes and codes outputs.\nIn the following two sections about R, you are supposed to submit .rmd/.qmd file.\n\n\n\n\n\n\nNote\n\n\n\nQuarto is an extension/continuation of R Markdown. Most R Markdown file can be directly translated to a Quarto file without many modifications. The main difference between R Markdown and Quarto is that Quarto has better support for other languages such as Python and Julia. You may go to its homepage for more details.\nThis note is produced by Quarto.\n\n\nThe most import part of R Markdown / Quarto is the code block, that is\n```{r}\nprint('Hello world!')\n```\nIn Quarto, you may also write\n```{python}\nprint('Hello world!')\n```\nThere are many options to adjust how the code blocks are excacuted. You don’t need to worry about them right now. Currently just try to write your report together with code blocks.",
    "crumbs": [
      "Part I: R Basic",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals</span>"
    ]
  },
  {
    "objectID": "contents/8/intro.html#data-structures",
    "href": "contents/8/intro.html#data-structures",
    "title": "1  R Fundamentals",
    "section": "1.3 Data structures",
    "text": "1.3 Data structures\nMain reference here is [1] and [2].\n\n1.3.1 Vectors\nVector is one of the basic data structure in R. It is created by c() function. Sometimes it is called atomic vector. You may store any data types in it. R recognizes six basic types: double, integers, characters, logicals, complex and raw.\nThe data type inside a vector can be checked by typeof function.\n\ndie &lt;- c(1, 2, 3, 4, 5, 6)\ntypeof(die)\n#&gt; [1] \"double\"\n\nFor consecutive numbers, an easier way to create vector is to use :.\n\ndie &lt;- 1:6\n\n\n\n\n\n\n\nCaution\n\n\n\nNote that vector index starts from 1 in R, while list index starts from 0 in Python.\n\n\n\ndie[1]\n#&gt; [1] 1\n\nWhen slicing with vectors, don’t forget to use c().\n\ndie[c(2, 3)]\n#&gt; [1] 2 3\n\n\ndie[2:3]\n#&gt; [1] 2 3\n\nYou may use length() function to get its length.\n\nlength(die)\n#&gt; [1] 6\n\n\n\n1.3.2 Attributes\nR objects may have attributes. Attributes won’t be shown by default when you show the object. You may find the attributes of a R object by calling the attributes() function.\nThe following example show that the vector die defined in Section 1.3.1 doesn’t have attributes.\n\nattributes(die)\n#&gt; NULL\n\nAttributes can be read and write using attr function. See the following example.\n\nExample 1.1  \n\nattr(die, 'date') &lt;- '2022-01-01'\ndie\n#&gt; [1] 1 2 3 4 5 6\n#&gt; attr(,\"date\")\n#&gt; [1] \"2022-01-01\"\nattr(die, 'date') &lt;- NULL\ndie\n#&gt; [1] 1 2 3 4 5 6\n\n\nYou may think attributes as metadata attached to a R object. They are used to tell some useful infomation of the object. Some functions will interact with certain attributes. R itself treat attributes class, comment, dim, dimnames, names, row.names and tsp specially. We will only talk about class and names here. dim will be discussed in the next section. Others will be discussed when we use them.\n\nclass: This is different from the class in Python. class in R is an attribute which talks about the class of an object. If the attribute class is not assigned to an object, the object will have an implicit class: matrix, array, function, numeric or the result of typeof.\n\nattr(x, 'class') will show the “external” class of an object. You may also use class(x) to read and write attribute class. If the class is not assigned, class(x) will show the implicit class, while attr(x, 'class') will show NULL.\n\nExample 1.2  \n\nattr(die, 'class')\n#&gt; NULL\nclass(die)\n#&gt; [1] \"integer\"\nclass(die) &lt;- 'a die'\nattr(die, 'class')\n#&gt; [1] \"a die\"\nclass(die)\n#&gt; [1] \"a die\"\n\n\n\nnames: This attribute is used to name each element in a vector. After the names are assigned, it won’t be displayed below the data like other attributes. It will be displayed above the data with correct alignment. Similar to class, you may use names() to read and write the attribute.\n\n\nExample 1.3  \n\nnames(die) &lt;- c('one', 'two', 'three', 'four', 'five', 'six')\ndie\n#&gt;   one   two three  four  five   six \n#&gt;     1     2     3     4     5     6\nattributes(die)\n#&gt; $names\n#&gt; [1] \"one\"   \"two\"   \"three\" \"four\"  \"five\"  \"six\"\nnames(die)\n#&gt; [1] \"one\"   \"two\"   \"three\" \"four\"  \"five\"  \"six\"\nis.vector(die)\n#&gt; [1] TRUE\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhen you store different types of data into a single vector in R, R will convert them into a single type. The default way to do so is\n\nif there are only logicals and numbers, logicals will be converted to numbers by TRUE-&gt;1 and FALSE-&gt;0.\nif characters are presented, all are converted to characters by what it is.\n\n\nc(1, TRUE)\n#&gt; [1] 1 1\nc('1', 1, TRUE)\n#&gt; [1] \"1\"    \"1\"    \"TRUE\"\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWe can apply regular operators to vectors. The defaul way is to apply the operators element-wise.\n\n\n\n\n1.3.3 matrices and arrays\n\nm &lt;- matrix(c(1,2,3,4,5,6), nrow=2)\nm[1, ]\n#&gt; [1] 1 3 5\n\nA matrix has dim attribute.\n\ndim(m)\n#&gt; [1] 2 3\n\nNote that by assigning and removing dim attribute, you may change the object between vectors and matrices.\n\nExample 1.4  \n\nm\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\nis.matrix(m)\n#&gt; [1] TRUE\nis.vector(m)\n#&gt; [1] FALSE\ndim(m)\n#&gt; [1] 2 3\ndim(m) &lt;- NULL\nm\n#&gt; [1] 1 2 3 4 5 6\nis.matrix(m)\n#&gt; [1] FALSE\nis.vector(m)\n#&gt; [1] TRUE\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe dim of a matrix/vector can be a long vector. In this case, it will become an array.\n\n\n\n\n1.3.4 factors\nFactor is speical vector. It is a way to handle categorical data. The idea is the limit the possible values. In a factor all possible values are called level, which is an attribute.\n\nExample 1.5 We would like to talk about all months. We first define a vector of the valid levels:\n\nmonth_levels &lt;- c(\n  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n)\n\nThen we could start to transform some month vector into factors, by the function factor().\n\nx1 &lt;- c(\"Dec\", \"Apr\", \"Jan\", \"Mar\")\ny1 &lt;- factor(x1, level=month_levels)\nsort(x1)\n#&gt; [1] \"Apr\" \"Dec\" \"Jan\" \"Mar\"\nsort(y1)\n#&gt; [1] Jan Mar Apr Dec\n#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\nNote that sorting y1 is based on the levels.\n\nx2 &lt;- c(\"Dec\", \"Apr\", \"Jam\", \"Mar\")\ny2 &lt;- factor(x2, level=month_levels)\ny2\n#&gt; [1] Dec  Apr  &lt;NA&gt; Mar \n#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\nNote that y2 contains NA value since there is an entry in x2 that is not valid.\n\n\n\n1.3.5 Lists\nList is very similar to a vector. The main difference is that vector can only store values, while list can store objects. The most typical example of objects is another vector. Please see the following example.\n\nExample 1.6  \n\nc(1:2, 3:4)\n#&gt; [1] 1 2 3 4\nlist(1:2, 3:4)\n#&gt; [[1]]\n#&gt; [1] 1 2\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 3 4\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe attributes of an object is stored in an array.\n\nm &lt;- matrix(c(1,2,3,4,5,6), nrow=2)\na &lt;- attributes(m)\nclass(a)\n#&gt; [1] \"list\"\n\n\n\n\n\n1.3.6 data.frame\nData.Frame is a list with the class attribute data.frame, together with some restriction on the shape of each columns. You may think about it in terms of tables.\n\ndf &lt;- data.frame(face = c(\"ace\", \"two\", \"six\"),\n                 suit = c(\"clubs\", \"clubs\", \"clubs\"),\n                 value = c(1, 2, 3))\ndf\n#&gt;   face  suit value\n#&gt; 1  ace clubs     1\n#&gt; 2  two clubs     2\n#&gt; 3  six clubs     3\n\n\nData Frame group vectors. Each vector represents a column.\nDifferent column can contain a different type of data, but every cell within one column must be the same type of data.\ndata.frame() can be used to create a data.frame.\nThe type of a data.frame is a list. Similar to matrix comparing to vector, a data.frame is a list with class data.frame, as well as a few other attributes.\n\n\n\n1.3.7 Examples\n\nExample 1.7 Consider a date.frame representing a deck of cards. Here we use expand.grid() to perform the Cartesian product.\n\nsuit &lt;- c('spades', 'hearts', 'clubs', 'diamonds')\nface &lt;- 1:13\ndeck &lt;- expand.grid(suit, face)\nhead(deck)\n#&gt;       Var1 Var2\n#&gt; 1   spades    1\n#&gt; 2   hearts    1\n#&gt; 3    clubs    1\n#&gt; 4 diamonds    1\n#&gt; 5   spades    2\n#&gt; 6   hearts    2\n\nWe may assign names to change the column names.\n\nnames(deck) &lt;- c('suit', 'face')\nhead(deck)\n#&gt;       suit face\n#&gt; 1   spades    1\n#&gt; 2   hearts    1\n#&gt; 3    clubs    1\n#&gt; 4 diamonds    1\n#&gt; 5   spades    2\n#&gt; 6   hearts    2\n\nNote that since suit and face are two vectors, merge() can also do the Cartesian product. expand.grid() is good for both vectors and data.frame.\n\ndeck &lt;- merge(suit, face)\nhead(deck)\n#&gt;          x y\n#&gt; 1   spades 1\n#&gt; 2   hearts 1\n#&gt; 3    clubs 1\n#&gt; 4 diamonds 1\n#&gt; 5   spades 2\n#&gt; 6   hearts 2\n\n\n\n\n1.3.8 Load data\n\n1.3.8.1 build-in datasets\nR has many build-in datasets. You may use data() to see all of them. Here are a few common datasets.\n\nmtcars: Motor Trend Car Road Tests: The data was extracted from the 1974 Motor Trend US magazine, and comprises fuel consumption and 10 aspects of automobile design and performance for 32 automobiles (1973–74 models)\n\n\ndata(mtcars)\n\n\niris: iris data set gives the measurements in centimeters of the variables sepal length, sepal width, petal length and petal width, respectively, for 50 flowers from each of 3 species of iris. The species are Iris setosa, versicolor, and virginica.\n\n\ndata(iris)\n\n\nToothGrowth: ToothGrowth data set contains the result from an experiment studying the effect of vitamin C on tooth growth in 60 Guinea pigs.\n\n\ndata(ToothGrowth)\n\n\nPlantGrowth: Results obtained from an experiment to compare yields (as measured by dried weight of plants) obtained under a control and two different treatment condition.\n\n\ndata(PlantGrowth)\n\n\nUSArrests: This data set contains statistics about violent crime rates by us state.\n\n\ndata(USArrests)\n\n\n\n1.3.8.2 Read from files\nThe build-in read.csv() function can directly read .csv file into a data.frame.\n\nExample 1.8 We use the file yob1880.txt from Chapter 5 here. Put the file in the working folder and run the following code.\n\ndf &lt;- read.csv('yob1880.txt', header = FALSE)\nhead(df)\n\nWe may also manually assign columns names.\n\nnames(df) &lt;- c('name', 'sex', 'counts')\nhead(df)\n#&gt;        name sex counts\n#&gt; 1      Mary   F   7065\n#&gt; 2      Anna   F   2604\n#&gt; 3      Emma   F   2003\n#&gt; 4 Elizabeth   F   1939\n#&gt; 5    Minnie   F   1746\n#&gt; 6  Margaret   F   1578\n\n\n\n\n\n\n\n\nNote\n\n\n\nTo save data is straightforward.\n\nwrite.csv(df, file='df.csv', row.names=FALSE)\n\n\n\n\n\n\n1.3.9 Flow control\n\n1.3.9.1 for loop\n\nExample 1.9  \n\nfor (x in 1:10){\n    print(x)\n}\n#&gt; [1] 1\n#&gt; [1] 2\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\n#&gt; [1] 6\n#&gt; [1] 7\n#&gt; [1] 8\n#&gt; [1] 9\n#&gt; [1] 10\n\n\n\n\n1.3.9.2 if-else\n\nExample 1.10  \n\na &lt;- 200\nb &lt;- 33\n\nif (b &gt; a) {\n  print(\"b is greater than a\")\n} else if (a == b) {\n  print(\"a and b are equal\")\n} else {\n  print(\"a is greater than b\")\n}\n#&gt; [1] \"a is greater than b\"\n\n\n\n\n1.3.9.3 Functions\nThe standard format to define a function is my_function &lt;- function(input) {} where the function name is on the left side of &lt;-, the input arguments are in the (), and the function body is in {}. The output of the last line of the function body is the return value of the function.\n\nExample 1.11  \n\nmyfunction &lt;- function() {\n    die &lt;- 1:6\n    sum(die)\n}\n\nmyfunction()\n#&gt; [1] 21\n\nIf you just type the function name without (), R will return the definition of the function.\n\nmyfunction\n#&gt; function() {\n#&gt;     die &lt;- 1:6\n#&gt;     sum(die)\n#&gt; }\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe function sample(x): sample takes a sample of the specified size from the elements of x using either with or without replacement.\nsample(x, size, replace = FALSE, prob = NULL):\n\nx: either a vector of one or more elements from which to choose, or a positive integer.\nsize: a non-negative integer giving the number of items to choose.\nreplace: should sampling be with replacement?\nprob: a vector of probability weights for obtaining the elements of the vector being sampled.",
    "crumbs": [
      "Part I: R Basic",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals</span>"
    ]
  },
  {
    "objectID": "contents/8/intro.html#r-notations",
    "href": "contents/8/intro.html#r-notations",
    "title": "1  R Fundamentals",
    "section": "1.4 R notations",
    "text": "1.4 R notations\n\n1.4.1 Selecting Values\nLet us start from a data.frame df. The basic usage is df[ , ], where the first index is to subset the rows and the second index is to subset the columns. There are six ways to writing indexes.\n\nPositive integers: the regular way.\n\n\ndf[i, j] means the data in the ith row and jth column.\nIf both i and j are vectors, a data.frame will be returned.\nIf i or j are a vector, a vector will be returned. If you still want a data.frame, you may add the option drop=FALSE.\nIf only one index is provided, it refers to the column.\n\n\nExample 1.12 We consider the simplified version of a deck. The deck only contains face values from 1 to 5.\n\ndeck[1:2, 1:2]\n#&gt;     Var1 Var2\n#&gt; 1 spades    1\n#&gt; 2 hearts    1\ndeck[1:2, 1]\n#&gt; [1] spades hearts\n#&gt; Levels: spades hearts clubs diamonds\ndeck[1:2, 1, drop=FALSE]\n#&gt;     Var1\n#&gt; 1 spades\n#&gt; 2 hearts\ndeck[1]\n#&gt;        Var1\n#&gt; 1    spades\n#&gt; 2    hearts\n#&gt; 3     clubs\n#&gt; 4  diamonds\n#&gt; 5    spades\n#&gt; 6    hearts\n#&gt; 7     clubs\n#&gt; 8  diamonds\n#&gt; 9    spades\n#&gt; 10   hearts\n#&gt; 11    clubs\n#&gt; 12 diamonds\n#&gt; 13   spades\n#&gt; 14   hearts\n#&gt; 15    clubs\n#&gt; 16 diamonds\n#&gt; 17   spades\n#&gt; 18   hearts\n#&gt; 19    clubs\n#&gt; 20 diamonds\n\n\n\nNegative integers: remove the related index.\n\nFor example,\n\ndeck[-1, 1:3] means it wants all rows except row 1, and column 1 to 3.\ndeck[-(2:20), 1:2] means it wants all rows ecepte row 2 to row 20, and column 1 to 2.\nNegative index and positive index cannot be used together in the same index.\n\n\nBlank Spaces: want every value in the dimension.\n\n\ndeck[, 1]\n#&gt;  [1] spades   hearts   clubs    diamonds spades   hearts   clubs    diamonds\n#&gt;  [9] spades   hearts   clubs    diamonds spades   hearts   clubs    diamonds\n#&gt; [17] spades   hearts   clubs    diamonds\n#&gt; Levels: spades hearts clubs diamonds\ndeck[1, ]\n#&gt;     Var1 Var2\n#&gt; 1 spades    1\n\n\nLogical values: select the rows or columns according to the value. The dimension should have exactly the same number of elements as the logical vector.\n\n\nrows &lt;- c(TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE)\ndeck[rows,]\n#&gt;        Var1 Var2\n#&gt; 1    spades    1\n#&gt; 3     clubs    1\n#&gt; 5    spades    2\n#&gt; 6    hearts    2\n#&gt; 8  diamonds    2\n#&gt; 10   hearts    3\n#&gt; 11    clubs    3\n#&gt; 13   spades    4\n#&gt; 15    clubs    4\n#&gt; 16 diamonds    4\n#&gt; 18   hearts    5\n#&gt; 20 diamonds    5\ndeck[1:2, c(TRUE, FALSE)]\n#&gt; [1] spades hearts\n#&gt; Levels: spades hearts clubs diamonds\n\n\nNames: select columns based on names attribute.\n\n\ndeck[, 'Var2']\n#&gt;  [1] 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5\n\n\n\n1.4.2 Dollar signs and double brackets\nList and data.frame obey an optional second system of notation. You can extract values using $ syntax: the data.frame’s name and the column name separated by a $ will select a column and return a vector (since the data in each column is actually a vector).\n\nExample 1.13 Here is an exmaple about data.frames.\n\ndeck[, 1]\n#&gt;  [1] spades   hearts   clubs    diamonds spades   hearts   clubs    diamonds\n#&gt;  [9] spades   hearts   clubs    diamonds spades   hearts   clubs    diamonds\n#&gt; [17] spades   hearts   clubs    diamonds\n#&gt; Levels: spades hearts clubs diamonds\ndeck$Var1\n#&gt;  [1] spades   hearts   clubs    diamonds spades   hearts   clubs    diamonds\n#&gt;  [9] spades   hearts   clubs    diamonds spades   hearts   clubs    diamonds\n#&gt; [17] spades   hearts   clubs    diamonds\n#&gt; Levels: spades hearts clubs diamonds\n\nNote that if we select from the data.frame using index, we will get a data.frame.\n\ndeck[1]\n#&gt;        Var1\n#&gt; 1    spades\n#&gt; 2    hearts\n#&gt; 3     clubs\n#&gt; 4  diamonds\n#&gt; 5    spades\n#&gt; 6    hearts\n#&gt; 7     clubs\n#&gt; 8  diamonds\n#&gt; 9    spades\n#&gt; 10   hearts\n#&gt; 11    clubs\n#&gt; 12 diamonds\n#&gt; 13   spades\n#&gt; 14   hearts\n#&gt; 15    clubs\n#&gt; 16 diamonds\n#&gt; 17   spades\n#&gt; 18   hearts\n#&gt; 19    clubs\n#&gt; 20 diamonds\nclass(deck[1])\n#&gt; [1] \"data.frame\"\n\n\n\nExample 1.14 Here is an example about lists.\n\nlst &lt;- list(numbers = c(1, 2), logical = TRUE, strings = c(\"a\", \"b\", \"c\"))\nlst$numbers\n#&gt; [1] 1 2\n\nNote that if we select from the list using index, we will get a list.\n\nlst[1]\n#&gt; $numbers\n#&gt; [1] 1 2\nclass(lst[1])\n#&gt; [1] \"list\"\n\n\nPlease think through these two examples and figure out the similarity between them.\n\n\n\n\n\n\nCaution\n\n\n\nUnderstanding the return value type is very important. Many of the R function work with vectors, but they don’t work with lists. So using the correct way to get values is very important.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThere is a command called attach() which let you get access to deck$face by just typing face. It is highly recommanded NOT to do this. It is much better to make everything explicit, especially when using IDE, typing is much easier.",
    "crumbs": [
      "Part I: R Basic",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals</span>"
    ]
  },
  {
    "objectID": "contents/8/intro.html#modifying-values",
    "href": "contents/8/intro.html#modifying-values",
    "title": "1  R Fundamentals",
    "section": "1.5 Modifying values",
    "text": "1.5 Modifying values\n\n1.5.1 Changing values in place\nYou can use R’s notation system to modify values within an R object.\n\nIn general when working with vectors, the two vectors should have the same length.\nIf the lengths are different, R will repeat the shorter one to make it match with the longer one. This is called the vector recycling rule. R will throw a warning if the two lengths are not proposional.\n\n\nExample 1.15  \n\n1:4 + 1:2\n#&gt; [1] 2 4 4 6\n1:4 + 1:3\n#&gt; Warning in 1:4 + 1:3: longer object length is not a multiple of shorter object\n#&gt; length\n#&gt; [1] 2 4 6 5\n\n\n\nWe may create values that do not yet exist in the object. R will expand the object to accommodate the new values.\n\n\nExample 1.16  \n\nvec &lt;- 1:6\nvec\n#&gt; [1] 1 2 3 4 5 6\nvec[7] &lt;- 0\nvec\n#&gt; [1] 1 2 3 4 5 6 0\n\n\n\nExample 1.17  \n\ndf &lt;- data.frame(a=c(1,2), b=c('a', 'b'))\ndf\n#&gt;   a b\n#&gt; 1 1 a\n#&gt; 2 2 b\ndf$c &lt;- 3:4\ndf\n#&gt;   a b c\n#&gt; 1 1 a 3\n#&gt; 2 2 b 4\n\n\n\n\n1.5.2 Logical subsetting\nWe could compare two vectors element-wise, and the result is a logical vector. Then we could use this result to subset the vector / data.frame.\n\nExample 1.18  \n\nsuit &lt;- c('spades', 'hearts', 'clubs', 'diamonds')\nface &lt;- 1:5\ndeck &lt;- expand.grid(suit, face)\n\n\ndeck$Var1 == 'hearts'\n#&gt;  [1] FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE\n#&gt; [13] FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE\ndeck$Var2[deck$Var1 == 'hearts']\n#&gt; [1] 1 2 3 4 5\ndeck[deck$Var1 == 'hearts',]\n#&gt;      Var1 Var2\n#&gt; 2  hearts    1\n#&gt; 6  hearts    2\n#&gt; 10 hearts    3\n#&gt; 14 hearts    4\n#&gt; 18 hearts    5\n\nWe could directly assign values to the subset. Note that the following assignment create a new column with NA values.\n\ndeck$Var3[deck$Var1 == 'hearts'] &lt;- 1\ndeck\n#&gt;        Var1 Var2 Var3\n#&gt; 1    spades    1   NA\n#&gt; 2    hearts    1    1\n#&gt; 3     clubs    1   NA\n#&gt; 4  diamonds    1   NA\n#&gt; 5    spades    2   NA\n#&gt; 6    hearts    2    1\n#&gt; 7     clubs    2   NA\n#&gt; 8  diamonds    2   NA\n#&gt; 9    spades    3   NA\n#&gt; 10   hearts    3    1\n#&gt; 11    clubs    3   NA\n#&gt; 12 diamonds    3   NA\n#&gt; 13   spades    4   NA\n#&gt; 14   hearts    4    1\n#&gt; 15    clubs    4   NA\n#&gt; 16 diamonds    4   NA\n#&gt; 17   spades    5   NA\n#&gt; 18   hearts    5    1\n#&gt; 19    clubs    5   NA\n#&gt; 20 diamonds    5   NA\n\n\n\n\n\n\n\n\nTip\n\n\n\nOther than the regualr logical operators, R provides a speical one: %in%.\nx %in% y: Is x in the vector y?\nIf x is a vector, the output is a vector with the same length as x, telling whether each element of x is in y or not.\n\n\n\n\n\n\n\n\nTip\n\n\n\nOther than the regular Boolean operators, R provides two special ones: any and all.\n\nany(cond1, cond2, ...): Are any of these conditions true?\nall(cond1, cond2, ...): Are all of these conditions true?\n\n\n\n\n\n1.5.3 Missing values NA\nIn R, missing values are NA, and you can directly work with NA. Any computations related to NA will return NA.\n\nna.rm: Most R functions come with the optional argument na.rm. If you set it to be TRUE, the function will ignore NA when evaluating the function.\n\n\nExample 1.19  \n\nmean(c(NA, 1:50))\n#&gt; [1] NA\nmean(c(NA, 1:50), na.rm=TRUE)\n#&gt; [1] 25.5\n\n\n\nis.na(): This is a function testing whether an object is NA.",
    "crumbs": [
      "Part I: R Basic",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals</span>"
    ]
  },
  {
    "objectID": "contents/8/intro.html#exercises",
    "href": "contents/8/intro.html#exercises",
    "title": "1  R Fundamentals",
    "section": "1.6 Exercises",
    "text": "1.6 Exercises\n\nExercise 1.1 Start a R Markdown / Quarto file. In the first section write a R code block to print Hello world!.\n\n\nExercise 1.2 Which of these are character strings and which are numbers? 1, \"1\", \"one\".\n\n\nExercise 1.3 Create an atomic vector that stores just the face names of the cards: the ace of spades, king of spades, queen of spades, jack of spades, and ten of spades. Which type of vector will you use to save the names?\nHint: The face name of the ace of spades would be ace and spades is the suit.\n\n\nExercise 1.4 Create the following matrix, which stores the name and suit of every card in a royal flush.\n\n#&gt;      [,1]    [,2]    \n#&gt; [1,] \"ace\"   \"spades\"\n#&gt; [2,] \"king\"  \"spades\"\n#&gt; [3,] \"queen\" \"spades\"\n#&gt; [4,] \"jack\"  \"spades\"\n#&gt; [5,] \"ten\"   \"spades\"\n\n\n\nExercise 1.5 Many card games assign a numerical value to each card. For example, in blackjack, each face card is worth 10 points, each number card is worth between 2 and 10 points, and each ace is worth 1 or 11 points, depending on the final score.\nMake a virtual playing card by combining “ace” “heart” and 1 into a vector. What type of atomic vector will result? Check if you are right, and explain your reason.\n\n\nExercise 1.6 Use a list to store a single playing card, like the ace of hearts, which has a point value of one. The list should save the face of the card, the suit, and the point value in separate elements.\n\n\nExercise 1.7 Consider the following data.frame.\n\nsuit &lt;- c('spades', 'hearts', 'clubs', 'diamonds')\nface &lt;- 1:5\ndeck &lt;- expand.grid(suit, face)\n\nPlease write some codes to count how many rows whose Var1 are equal to hearts.\n\n\nExercise 1.8 Converte the following sentences into tests written with R code.\n\nw &lt;- c(-1, 0, 1). Is w positive?\nx &lt;- c(5, 15). Is x greater than 10 and less than 20?\ny &lt;- 'February'. Is object y the word February?\nz &lt;- c(\"Monday\", \"Tuesday\", \"Friday\"). Is every value in z a day of the week?\n\n\n\nExercise 1.9 Please write a function to shuffle the row of a data.frame. You may use the following data.frame deck for test.\n\nsuit &lt;- c('spades', 'hearts', 'clubs', 'diamonds')\nface &lt;- 1:13\ndeck &lt;- expand.grid(suit, face)\n\n\n\n\n\n\n[1] Grolemund, G. (2014). Hands-on programming with r: Write your own functions and simulations. O’Reilly Media.\n\n\n[2] Wickham, H. and Grolemund, G. (2017). R for data science: Import, tidy, transform, visualize, and model data. O’Reilly Media.",
    "crumbs": [
      "Part I: R Basic",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals</span>"
    ]
  }
]